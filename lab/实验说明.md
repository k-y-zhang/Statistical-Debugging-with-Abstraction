# 补充实验的说明

## 研究背景


将数据挖掘中的关联分析算法用于缺陷定位。



## 实验目的

将原本的实验在新的数据集上进行实验并收集数据进行分析。



## 论文

- Toward More Efficient Statistical Debugging with Abstraction Refinement 
  - 包含两个方面的工作
    1. 挖掘 bug 相关（比如根据IG）的 predicates 
    2. 定位怀疑度最高的 predicates
  - 保证结果不变，优化性能
- Efficient Predicated Bug Signature Mining via Hierarchical Instrumentation
  - 收集和bug相关（IG）的predicates，结果不变的情况下优化性能
  - 多步，有选择性的插桩。
  - IG的大小根据失败和通过的测试用例数量来计算
  - 分三步 1 按函数插桩 2 部分位置插桩得到阈值 3 全部阈值之上的位置
  - 能保证结果不变
- SIR
  - 数据集
- defects4j
  - 另一个数据集 

- code
   - https://github.com/z-zhiqiang/JSampler
   - https://github.com/z-zhiqiang/HI

## 实验环境

执行以下步骤后，得到实验的初始环境，后面实验都在该环境下进行。

这个版本下一开始写调用的命令都不完全兼容了（除了 apt 甚至包括 sed），没想到才没几年。

主要目的是为了满足 mps 和 java 7 两个依赖。



首先


```sh
screen -RR # 保持连接
# 进入容器
docker run -it --rm -v $PWD:$PWD -w $PWD ubuntu:12.04
```

然后

```sh
# 安装依赖的库
sed -i -re 's/archive/old-releases/g' /etc/apt/sources.list
apt-get update
apt-get install -y wget openjdk-7-jre openjdk-7-jdk subversion cpanminus git build-essential patch  ruby1.9.1  unzip
apt-get install -y libboost-program-options1.46 antlr3 libprotobuf-c0 libantlr3c-dev 
# 安装defects4j
git clone https://github.com/rjust/defects4j.git
cd defects4j
git checkout v1.5.0
./init.sh
cpan install DBI DBD::CSV URI JSON JSON::Parse List::Util
#cpanm --installdeps .
```

代码在本地编写，这里用 vscode 的 sftp 插件同步到服务器执行。


安装 sampler-cc

```sh
docker run -it --rm fedora:20 bash
wget https://research.cs.wisc.edu/cbi/downloads/rpm/fedora/20/tools/x86_64/cbi-package-config-20-13.noarch.rpm
rpm -i cbi-package-config-20-13.noarch.rpm
yum install sampler-devel
```

## 实验说明



- 怀疑度根据失败和通过的测试用例计算，插桩方式不影响计算得到的数值，只会没收集到但是一旦收集到了数值就确定了。如果能确定某处怀疑度一定小于某值的话，那么不需要就可以不收集。



### 实验  1

针对论文《Efficient Predicated Bug Signature Mining via Hierarchical Instrumentation》

得到与 bug 相关的predicates 集合，在结果（top-k）不变的情况下优化性能。

原理：减少插桩数，通过粗粒度的插桩收集信息。

评价指标：测试用例执行用时，收集数据的大小。

研究问题：



### 实验 2



RQ1 和 RQ2 针对两种插桩方式下执行的测试用例，收集怀疑度数据。

RQ3 收集不同的插桩方式测试用例的执行时间。

RQ4 迭代收敛



## 具体步骤


见脚本

实验 1 
-  himps.jar
-  preprocess.jar
- mbs

实验 2

- HI.jar

对原实验脚本的修改
recaf
CBI 换成了

### 实验一的修改

- himps.jar 的 scheme="function-entries" 改为 method-entries



### 实验二

疑度公式的修改

- HI.jar
- zuo.processor.cbi.processor.Processor#importance
- SelectingProcessor


-  printOutMethodsListByMode

package zuo.processor.cbi.processor.Processor;

原始代码
```java
  public static double importance(int neg_t, int pos_t, int neg, int pos, int totalNeg, int totalPos) {
    assert neg_t <= neg && pos_t <= pos;
    if (neg_t <= 1 || pos_t + neg_t == 0)
      return 0.0D; 
    double increase = neg_t / (pos_t + neg_t) - neg / (pos + neg);
    if (increase < 0.0D || Math.abs(increase - 0.0D) < 1.0E-7D)
      return 0.0D; 
    return 2.0D / (1.0D / increase + Math.log(totalNeg) / Math.log(neg_t));
  }
```

修改为

```java
public static double importance(int neg_t, int pos_t, int neg, int pos, int totalNeg, int totalPos) {
  assert neg_t <= neg && pos_t <= pos;
if (neg == 0 || pos_t + neg_t == 0)
  return 0;
return neg_t/Math.sqrt(neg*(pos_t + neg_t));
}
```



package zuo.processor.functionentry.processor.SelectingProcessor;

H_1

DH

TODO: 这个地方要改么？

## TODO



work in process

- 实验 1 收集的数据
- RQ3 iteratively instrumented program - only one function is refined at each iteration
- RQ 4



- exp1 汇总的数据。
- 从 RQ1/2 到 3
- RQ4 跑

- 先把 Lang 和 Chart 跑完整，其他的实在太耗时间了。然后再考虑优化性能。
- 目前判断 JUnit 的版本的方法有点问题。
- 性能问题，执行测试用例的时候
- 进一步改进，
  - 把 soot 换成 asm
  - 执行单元测试效率


