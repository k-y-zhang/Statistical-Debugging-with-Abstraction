# 关于 zuo 论文在 defects4j 上的补充实验

目前实验在 zhangsy@210.28.135.32:/home/zhangsy/2021C/ 运行

## 实验 1

## 

himps.jar

原来实验和现在实验吧两者输出不是完全一致，需要对代码一些修改

- 注意输出中的 scheme="method-entries" 改为 function-entries

- 注意改 getUniqueFunctionName 中对路劲的处理

- 注意输入文件 sites 和 profile 文件 两字unit 中对不上



关于mps的运行环境：
docker run -it --rm -v $PWD:$PWD -w $PWD ubuntu:12.04
docker run -it --rm ubuntu:1204
docker run -it --rm -v $PWD:$PWD -w $PWD ubuntu:12.04

sed -i -re 's/archive/old-releases/g' /etc/apt/sources.list # 添加源列表

apt-get update

apt-get install wget openjdk-7-jre 

cat /etc/apt/sources.list

apt-get intall libboost-program-options1.46 antlr3
apt-cache search libprotobuf antlr3

-sampler-include-method=

openjdk-7-jre 

## 实验 2

## 脚本运行

先（必须）在当前目录下运行 bash run.sh 进入 docker 容器

然后运行

- bash x1.sh 运行全部测试（很耗时）
- bash x2.sh Lang 2 cg 运行一个（如果只缺哪个就运行这个）
  - 三个参数为：项目 + 编号 + 方法
- bash x3.sh 分析结果（也很耗时）

注意

- 前两个脚本会清空之前的的对应的一条数据。

- 远程访问时，先进 screen 再进 docker，以保持进程可以后台执行。
- 某一个项目单用户单进程运行，不同项目版本处理可以并行。
- 容器里已经装好依赖的库和版本了
- 运行 x3 前检查是否对应的运行数据是否齐全。
  - 包括遗漏或者运行失败。



## 脚本的输出

目录

- tmp 为插桩后的代码    <---- 由 x2.sh 生成

- nanoxml为测试用例运行结果 <---- 由 x2.sh 生成

- log 为运行日志   <---- 由 x2.sh 生成

- out 为分析结果 <---- 由 x3.sh 生成



## 原实验和RQ



RQ 1

 runAll_inst.sh + HI.jar

 其中 runAll_inst.sh 对每个版本执行 cg 和 fg 两者插桩方式。


输出文件为 traces versions 两个目录
RQ 2

数据同上 + HI_branch.jar

RQ 3

比较用时

 runAll overhead.sh + zuo.util.readfile.IterativeTimeReade

runAll overhead.sh 除了 调用 runAll_inst.sh 对每个版本执行 cg 和 fg 两者插桩方式。
还执行原始版本和采样版本

输出文件为 outputs.alt

RQ4

 runAll inst.sh +  zuo.processor.functionentry.client.iterative.Client_Ranking



## 怀疑度公式



参考代码

https://bitbucket.org/rjust/fault-localization-data/src/master/analysis/pipeline-scripts/previously-studied-flts/formulas.py

```python
def ochiai(passed, failed, totalpassed, totalfailed):
  if totalfailed == 0 or (passed+failed == 0):
    return 0
  return failed/(totalfailed*(failed+passed))**0.5

def cbi_inc(passed, failed, totalpassed, totalfailed):
  return (failed / failed + passed) - ((totalfailed - failed) / ((totalfailed - failed) + (totalpassed - passed)))

def cbi_log(passed, failed, totalpassed, totalfailed):
  if failed == 0 or totalfailed - failed == 0:
    return 0
  return 2 / ((1 / cbi_inc(passed, failed, totalpassed, totalfailed)) + (math.log(totalfailed - failed) / math.log(failed)))

```



failed=neg_t

totalNeg=totalfailed - failed

failed + passed=pos_t + neg_t

totalfailed - failed=neg

((totalfailed - failed) + (totalpassed - passed)==(pos + neg)

totalpassed - passed=pos





HIljar 的原始代码

```java
  public static double importance(int neg_t, int pos_t, int neg, int pos, int totalNeg, int totalPos) {
    assert neg_t <= neg && pos_t <= pos;
    if (neg_t <= 1 || pos_t + neg_t == 0)
      return 0.0D; 
    double increase = neg_t / (pos_t + neg_t) - neg / (pos + neg);
    if (increase < 0.0D || Math.abs(increase - 0.0D) < 1.0E-7D)
      return 0.0D; 
    return 2.0D / (1.0D / increase + Math.log(totalNeg) / Math.log(neg_t));
  }

```





## hi.jar 的 修改

怀疑度公式修改为

```java
  // package zuo.processor.cbi.processor.Processor;
//375 324
  public static double importance(int neg_t, int pos_t, int neg, int pos, int totalNeg, int totalPos) {
    assert neg_t <= neg && pos_t <= pos;
  if (neg+neg_t == 0 || pos_t + neg_t == 0)
    return 0;
  return neg_t/Math.sqrt((neg+neg_t)*(pos_t + neg_t));
  }
```

版本2
```java
  // package zuo.processor.cbi.processor.Processor;
//375 324
  public static double importance(int neg_t, int pos_t, int neg, int pos, int totalNeg, int totalPos) {
    assert neg_t <= neg && pos_t <= pos;
  if (neg == 0 || pos_t + neg_t == 0)
    return 0;
  return neg_t/Math.sqrt(neg*(pos_t + neg_t));
  }
```


```java
//zuo.processor.functionentry.processor.SelectingProcessor; 
public int computeCBIBound(double threshold) {
    if (DH(2, this.totalPositive) <= 0.0D)
      throw new RuntimeException("abnormal case 1");//把这行注释掉，检查测试用例数是否大于等于 2
```





修改文件包括

- HI.jar
- HI_scalar.jar
  HI_return.jar
  HI_branch.jar

这三个文件做同样的修改



其他修改

```JAVA
//zuo.processor.functionentry.client.iterative.java.JavaClient
//104;
return Pattern.matches("subv[0-9]*", name) && new File(dir, name).listFiles().length >= 1;//把检查文件数去掉

// package zuo.processor.cbi.client.CBIClient;
// private void increasePartialSamples(Set<Integer> failingSet, Set<Integer> passingSet, double percent) {
        while (failingSet.size() < (fs > 2 ? fs : 2)) {
//失败测试用例个数最小值去掉
```





字节码用 `jd-gui` 阅读，直接用 `recaf` 工具修改（反编译器选第三个）。



修改会影响 xls 的运行结果



## 遇到的问题



- 对怀疑度的修改，要求失败测试用例大于等于2？修改后的方法是否合适？
- adaptive 是怎么回事（这个怎么做，需要先自动分析代码？）

- Mockito这个项目是 mock  的 junit，目前的脚本会把Mockito的单元测试和Mockito的单元测试的里用来测试的单元测试混在一起，从而执行失败。看看这个实验对象是否合适实验？
- 过一遍 log，看看有什么执行不对的地方。（这个要过）



## 其他注意点

- main函数的插桩位置，用于导出数据
- 处理不同java项目的差异，包括

```sh
# defects4j 中不同的项目由不同的结构
# - 不同的项目目录结构的差异
# - 构建工具 maven 和 ant
# - 版本管理 git 和 svn
# - JUnit3 和 JUnit 4 的语法差异
# - Java 版本差异，比如 Java 1.4 不支持范型，Java 1.7 和 1.8
# - mockito 是测试用的
#
# 解决思路
# - defect4j 数据集在不断扩充，且版本多，不想把条件写死
#
# 解决办法
# - defect4j 提供一些元信息
# - 脚本对不同情况这些都有判断

# JSampler 中依赖的 Soot 版本是 Java1.7，升级 Soot 会有不兼容的地方，所以暂时限定 Java 1.7 跑。
# Defect4j 的 1.5 依赖 Java 7，2.0 依赖 Java 7
```



